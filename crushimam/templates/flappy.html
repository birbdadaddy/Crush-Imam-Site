{% extends 'crushimam/base.html' %}

{% block title %}Flappy - Crush Imam{% endblock %}

{% block body_class %}flappy-body{% endblock %}
{% block content %}


<div class="flappy-container">
  <h2>Flappy Bird</h2>
  <canvas id="game" width="480" height="640"></canvas>
  <form style="display:none">{% csrf_token %}</form>
  <div class="hud">
    <div class="score">Score: <span id="score">0</span></div>
    {% if user.is_authenticated %}
      <div style="display:flex;gap:.5rem;align-items:center">
        <button id="play" class="btn btn-primary btn-play">Play</button>
      </div>
    {% else %}
      <a id="play" class="btn btn-primary btn-play" href="{% url 'account_login' %}?next={% url 'flappy' %}">Login to Play</a>
    {% endif %}
  </div>

  <div class="leaderboard">
    <h3><i class="fa-solid fa-trophy text-yellow"></i> Leaderboard</h3>
    <table id="leaderboard">
      <thead><tr><th>#</th><th>Smiya</th><th>Score</th><th>F</th></tr></thead>
      <tbody>
        {% for s in top_scores %}
        <tr><td>{{ forloop.counter }}</td><td>{{ s.name }} {% if s.name == request.user.username %} (You) {% endif %}</td><td>{{ s.score }}</td><td>{{ s.achieved_at|date:"Y-m-d H:i" }}</td></tr>
        {% empty %}
        <tr><td colspan="4">ba9i ma kaynch chi score. Kon lwl</td></tr>
        {% endfor %}
      </tbody>
    </table>
  </div>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
// Flappy Bird Game - Rewritten & Improved (with randomized gaps)
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const BASE_WIDTH = 480;
const BASE_HEIGHT = 580; // leaves room for ground

let scaleRatio = 1;
let width = BASE_WIDTH;
let height = BASE_HEIGHT;

function resizeCanvas() {
  scaleRatio = window.devicePixelRatio || 1;
  canvas.width = BASE_WIDTH * scaleRatio;
  canvas.height = BASE_HEIGHT * scaleRatio;
  canvas.style.width = '100%';
  canvas.style.height = '100%';
  ctx.setTransform(scaleRatio, 0, 0, scaleRatio, 0, 0);
  width = BASE_WIDTH;
  height = BASE_HEIGHT;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Game constants
const GRAVITY = 0.35;
const FLAP_STRENGTH = -8.5;
const PIPE_SPEED = 2.2;
const PIPE_WIDTH = 70;
const PIPE_INTERVAL = 1400; // ms between pipes
const GROUND_HEIGHT = 60;
const MIN_GAP = 140;      // Minimum gap size
const MAX_GAP = 220;      // Maximum gap size
const MIN_PIPE_HEIGHT = 80; // Minimum height for top/bottom pipes

// Game state
let bird = {
  x: 100,
  y: height / 2,
  vy: 0,
  radius: 16
};

let pipes = [];
let score = 0;
let bestScoreThisSession = 0;
let lastPipeTime = 0;
let playing = false;
let gameOver = false;

let animationId = null;
let lastFrameTime = 0;

// Reset game
function resetGame() {
  bird.y = height / 2;
  bird.vy = 0;
  pipes = [];
  score = 0;
  lastPipeTime = 0;
  playing = true;
  gameOver = false;
  document.getElementById('score').textContent = '0';
}

// Flap
function flap() {
  if (!playing) startGame();
  bird.vy = FLAP_STRENGTH;
}

// Start or resume game
function startGame() {
  if (playing) return;
  resetGame();
  lastFrameTime = performance.now();
  loop(lastFrameTime);
}

// Game over
function endGame() {
  playing = false;
  gameOver = true;
  cancelAnimationFrame(animationId);
  bestScoreThisSession = Math.max(bestScoreThisSession, score);
  setTimeout(submitScore, 500);
}

// Spawn a pipe pair with RANDOMIZED GAP
function spawnPipe(currentTime) {
  if (currentTime - lastPipeTime < PIPE_INTERVAL) return;

  // Random gap size
  const gap = MIN_GAP + Math.random() * (MAX_GAP - MIN_GAP);

  // Available height for pipes (excluding ground and gap)
  const availableHeight = height - GROUND_HEIGHT - gap;

  // Ensure enough space for min pipe heights
  if (availableHeight < 2 * MIN_PIPE_HEIGHT) return; // Skip if impossible (rare)

  // Random top pipe height within valid range
  const topHeight = MIN_PIPE_HEIGHT + Math.random() * (availableHeight - 2 * MIN_PIPE_HEIGHT);

  pipes.push({
    x: width,
    topHeight: topHeight,
    bottomY: topHeight + gap,
    scored: false
  });
  lastPipeTime = currentTime;
}

// Update physics (delta-time based for smoothness)
function update(delta) {
  if (!playing) return;

  // Bird physics
  bird.vy += GRAVITY * delta / 16; // normalize to ~60fps
  bird.y += bird.vy * delta / 16;

  const currentTime = performance.now();
  spawnPipe(currentTime);

  // Update pipes
  for (let i = pipes.length - 1; i >= 0; i--) {
    const pipe = pipes[i];
    pipe.x -= PIPE_SPEED * delta / 16;

    // Score
    if (!pipe.scored && bird.x > pipe.x + PIPE_WIDTH) {
      pipe.scored = true;
      score++;
      document.getElementById('score').textContent = score;
    }

    // Remove off-screen pipes
    if (pipe.x + PIPE_WIDTH < 0) {
      pipes.splice(i, 1);
    }
  }

  // Collisions
  if (bird.y + bird.radius > height - GROUND_HEIGHT || bird.y - bird.radius < 0) {
    endGame();
    return;
  }

  for (const pipe of pipes) {
    if (bird.x + bird.radius > pipe.x && bird.x - bird.radius < pipe.x + PIPE_WIDTH) {
      if (bird.y - bird.radius < pipe.topHeight || bird.y + bird.radius > pipe.bottomY) {
        endGame();
        return;
      }
    }
  }
}

// Render everything
function draw() {
  // Sky
  ctx.fillStyle = '#70c5ce';
  ctx.fillRect(0, 0, width, height);

  // Pipes
  pipes.forEach(pipe => {
    ctx.fillStyle = '#2d9c2f';

    // Top pipe + cap
    ctx.fillRect(pipe.x, 0, PIPE_WIDTH, pipe.topHeight);
    ctx.fillRect(pipe.x - 8, pipe.topHeight - 40, PIPE_WIDTH + 16, 40); // cap

    // Bottom pipe + cap
    ctx.fillRect(pipe.x, pipe.bottomY, PIPE_WIDTH, height - GROUND_HEIGHT - pipe.bottomY);
    ctx.fillRect(pipe.x - 8, pipe.bottomY, PIPE_WIDTH + 16, 40); // cap

    // Subtle shadows
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.fillRect(pipe.x + 6, 0, PIPE_WIDTH, pipe.topHeight);
    ctx.fillRect(pipe.x + 6, pipe.bottomY, PIPE_WIDTH, height - GROUND_HEIGHT - pipe.bottomY);
    ctx.fillStyle = '#2d9c2f'; // reset
  });

  // Ground
  ctx.fillStyle = '#a67c52';
  ctx.fillRect(0, height - GROUND_HEIGHT, width, GROUND_HEIGHT);
  ctx.fillStyle = '#8c6239';
  ctx.fillRect(0, height - GROUND_HEIGHT + 10, width, 20); // darker grass line

  // Bird
  const angle = Math.min(Math.max(bird.vy / 10, -0.5), 0.8); // tilt based on velocity

  ctx.save();
  ctx.translate(bird.x, bird.y);
  ctx.rotate(angle);

  // Body
  ctx.fillStyle = '#ffdd57';
  ctx.beginPath();
  ctx.arc(0, 0, bird.radius, 0, Math.PI * 2);
  ctx.fill();

  // Wing
  ctx.fillStyle = '#e6b800';
  ctx.beginPath();
  ctx.ellipse(-6, 0, bird.radius * 0.8, bird.radius * 0.5, -0.4, 0, Math.PI * 2);
  ctx.fill();

  // Eye
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(8, -4, 6, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.arc(9, -4, 3, 0, Math.PI * 2);
  ctx.fill();

  // Beak
  ctx.fillStyle = '#ff8c00';
  ctx.beginPath();
  ctx.moveTo(14, 0);
  ctx.lineTo(22, -3);
  ctx.lineTo(22, 3);
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}

// Main game loop
function loop(currentTime) {
  if (!lastFrameTime) lastFrameTime = currentTime;
  const delta = currentTime - lastFrameTime;
  lastFrameTime = currentTime;

  update(delta);
  draw();

  if (playing) {
    animationId = requestAnimationFrame(loop);
  }
}

// Input handling
function handleInput(e) {
  e.preventDefault();
  flap();
}

canvas.addEventListener('touchstart', handleInput, { passive: false });
canvas.addEventListener('mousedown', handleInput);
document.addEventListener('keydown', e => {
  if (e.code === 'Space') {
    e.preventDefault();
    flap();
  }
});

// Play button
const playEl = document.getElementById('play');
if (playEl) {
  playEl.addEventListener('click', e => {
    if (playEl.tagName.toLowerCase() === 'a') return; // login link
    e.preventDefault();
    startGame();
  });
}

// Score submission (unchanged logic, just moved)
function getCookie(name) {
  const match = document.cookie.match(new RegExp('(^|;) ?' + name + '=([^;]*)(;|$)'));
  return match ? decodeURIComponent(match[2]) : null;
}

function submitScore() {
  const csrf = getCookie('csrftoken');
  const formData = new FormData();
  formData.append('score', score);

  fetch('{% url "save_flappy_score" %}', {
    method: 'POST',
    body: formData,
    headers: { 'X-CSRFToken': csrf }
  })
  .then(async response => {
    if (response.status === 403) {
      window.location.href = "{% url 'account_login' %}?next={% url 'flappy' %}";
      return;
    }
    const data = await response.json();
    if (data.success) {
      populateLeaderboard(data.top);
    } else if (data.error) {
      alert('Error: ' + data.error);
    }
  })
  .catch(err => {
    console.error(err);
    alert('Network error');
  });
}

function populateLeaderboard(list) {
  const tbody = document.querySelector('#leaderboard tbody');
  tbody.innerHTML = '';
  list.forEach((entry, i) => {
    const row = document.createElement('tr');
    const date = new Date(entry.achieved_at).toLocaleString();
    const name = escapeHtml(entry.name);
    row.innerHTML = `<td>${i + 1}</td><td>${name}</td><td>${entry.score}</td><td>${date}</td>`;
    tbody.appendChild(row);
  });
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}
</script>
{% endblock %}